# 너비우선탐색을 베이스로 한 최단거리, 최장거리 찾기.

### 사용한 자료구조
**인접리스트 사용. 해당 vertex와 인접한 vertex들을 링크리스트로 연결함**

***

### 거리 탐색 기본알고리즘 설명.
**최단거리 최장거리를 찾는 알고리즘은 다음과 같다. 참고로 집이 1~64번까지의 집이 있다면, 
1번을 기준으로 2번부터 63번까지의 거리를 한꺼번에 찾는 알고리즘이다.**

**1. 처음 시작점을 기준으로 그 인접한곳을 탐색.**

**2. 인접한 곳을 전부 큐에 넣음**

**3. 큐에 넣은 vertex를 하나씩 꺼내서 그 인접한 곳을 탐색**

**4. 만약 시작점과 거리가 같은 곳을 전부 탐색했다면 distance값을 1증가**

**5. 이렇게 반복하다가 만약 해당 거리에 집인 vertex가 존재한다면 distance값이 시작점과 집까지의 거리임**

***

### 멀티코어 활용을 위한 방법 설명.

**위의 알고리즘을 바탕으로 만든 Search()함수를 만약 집이 64개, 코어가 36개라면 
코어당 한 스레드, 각 스레드마다 각각의 집을 기준으로 Search()함수를 돌리는 방식으로 만듬.
예를 들어 스레드 1~36이 동시에 집 1번에서 36번까지를 기준으로 탐색을 하고 만약 1번스레드가 끝나면 다시 37번 집을
기준으로 탐색하는 방법으로 구현**

**방문 여부를 각 스레드마다 배열로 관리를 통해서 스레드들끼리 충돌을 방지하고 방문여부확인하는 속도를 O(1)로 한다.**

***

### 빠르게 거리를 찾기위해 적용한 것들.(이게 핵심)

**1. 그 처음찾는집은 64개집을찾는다치면 그다음은 63개, 62개 ... 이런식으로 찾는 집을 줄여나간다.**
++단일 스레드 40만개 기준 12초에서 8초로 줄어듬.++

**2. 인접리스트로 만든 자료구조를 배열로 만들고, 큐 또한 배열로 그냥 전부 저장을 하는 식으로 해서 삭제연산을 없앤다.**
++단일 스레드 40만개 기준 8초에서 4.6초대로 줄어듬.++

**3. 프로그램상 모든 변수는 양수이므로 int들은 전부 unsigned로 선언하고 Search()함수안의 변수들을 register형으로 각 변수들이
레지스터상에서 연산이 되도록 해서 속도를 높이고 while문 안의 비교연산은 필요없기 때문에 없애고 for문을 do-while로 바꾼다.**
++단일 스레드 40만개 기준 4.6초에서 3.7초로 줄어듬.++

**4. 인접한 곳의 방문여부를 확인할 때 그 곳이 집인것을 확인하던 알고리즘을 해당 vertex에서 인접한 vertex들을 구할 때, 
이때 해당 vertex와 인접한 곳에 house들이 있는지를 미리 자료구조를 생성할 때 저장해두고 해당 vertex에서 집이 존재하는지 여부를
확인 하는 식으로 통해서 좀더 빨리 while문이 끝나도록 유도**
++200만개 조교님 컴퓨터 기준으로 0.2초 빨라짐...++